import{_ as e,c as t,o as i,a4 as l}from"./chunks/framework.BHUpnhyN.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"react/redux/README.md","filePath":"react/redux/README.md"}'),r={name:"react/redux/README.md"},a=l(`<h2 id="redux" tabindex="-1">redux <a class="header-anchor" href="#redux" aria-label="Permalink to &quot;redux&quot;">​</a></h2><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><p>专门用于状态管理的JS库，不是react的插件，仅仅是名字和react有点像 可以用在react vue angular 但是基本是与react配合使用，因为vue有vuex 作用：集中式管理react应用中多个组件共享的状态</p><p>场景：</p><ol><li>某个组件的状态，需要让其他组件随市可以获取到（共享）</li><li>一个组件需要改变另一个组件的状态（通信）</li><li>能不用就不用</li></ol><h3 id="三个核心概念" tabindex="-1">三个核心概念 <a class="header-anchor" href="#三个核心概念" aria-label="Permalink to &quot;三个核心概念&quot;">​</a></h3><ol><li><p>action</p><ul><li>一个动作对象，用来描述想怎么改数据，在某些场景也可以是一个函数类型</li><li>包含两个属性 type 标识属性，值为字符串 data 数据属性 值是任意类型</li></ul></li><li><p>reducer</p><ul><li>一个函数，用于初始化状态，加工状态，根据action对象的描述生成一个新的状态数据</li><li>加工时，根据旧的state和action，产生新的state的纯函数</li></ul></li><li><p>store</p><ul><li>一个对象，将state action reducer联系在一起的对象</li><li>使用createStore函数传入reducer函数，创建一个store</li><li>store的subscribe方法订阅数据变化</li><li>store的dispatch提交action对象触发reducer状态数据变化</li><li>store的getState方法获取状态数据更新到视图</li></ul></li></ol><h3 id="_01-求和案例" tabindex="-1">01_求和案例 <a class="header-anchor" href="#_01-求和案例" aria-label="Permalink to &quot;01_求和案例&quot;">​</a></h3><p>首先不使用redux来写一个求和按钮<strong>01_原始版求和</strong></p><p>页面要素：求和的值、下拉框可选择数字、加号按钮、减号按钮、和为奇数才触发加法的按钮、异步的加号按钮 四个按钮分别触发不同的事件计算求和的值，求和的值使用state.count，每次通过setState更新count的值</p><h3 id="_02-精简版redux的写法" tabindex="-1">02_精简版redux的写法 <a class="header-anchor" href="#_02-精简版redux的写法" aria-label="Permalink to &quot;02_精简版redux的写法&quot;">​</a></h3><p>精简版先不写action，只写必要的store和reducer</p><p>基于求和案例，创建redux目录 创建store.js count_reducers.js</p><ol><li><p>store</p><ul><li>引入count_reducers.js</li><li>文件专门用于抛出一个store对象，整个应用只有一个store对象</li><li>从redux引入creatStore方法，创建store对象</li><li>调用creatStore并传入count_reducers</li></ul></li><li><p>count_reducers.js</p><ul><li>该文件是用于创建一个count组件的reducer，本质是一个函数接收两个参数(preState，action)，初始化状态和加工状态</li><li>参数preState是更新前的状态值</li><li>参数action是一个对象，包含type和data</li><li>获取action对象的type和data</li><li>type在这个案例里有加和减，判断这两种场景，用preState和data做计算</li><li>default写初始化的值，在这个案例中默认值赋值为0</li></ul></li><li><p>count组件</p><ul><li>引入store.js</li><li>把count状态交给redux处理，获取状态使用<code>store.getState()</code>，设置状态使用<code>store.dispatch({ type, data })</code></li><li>dispatch只会更新状态，不会进行render，需要自行更新，在组建中可以监听<code>store.subscribe(callback)</code>，任何数据变更后会执行回调</li><li>store.subscribe可以在每个组件中自己定义调用<code> this.setState({})</code>强制render，也可以放到最外层的index.js重新render整个应用</li></ul></li></ol><h3 id="_03-增加action的写法" tabindex="-1">03_增加action的写法 <a class="header-anchor" href="#_03-增加action的写法" aria-label="Permalink to &quot;03_增加action的写法&quot;">​</a></h3><p>基于精简版，增加action的写法，在精简版中是在count组件中写的<code>{ type, data }</code>，这就是一个action对象，这里把它交给count_action.js来处理</p><ol><li><p>count_action.js</p><ul><li>该文件专门为count组件生成action对象（<code>{ type, data }</code>）</li><li>抛出加法和减法的函数，函数return一个action对象</li></ul></li><li><p>count组件</p><ul><li>引入action抛出的加法和减法函数，dispatch函数的传参由对象改为action函数的调用</li></ul></li><li><p>constant.js</p><ul><li>该文件用于定义action对象中type对象的常量值</li><li>在reduxcers和action引入constant.js，reduxcers和action中的常量都在这里声明</li></ul></li></ol><h3 id="_04-高级操作-异步action" tabindex="-1">04_高级操作_异步action <a class="header-anchor" href="#_04-高级操作-异步action" aria-label="Permalink to &quot;04_高级操作_异步action&quot;">​</a></h3><p>action除了是Object类型，还可以是Function类型，其中dispatch处理Object类型只能同步执行，如果需要异步执行，需要将异步操作包装在一个函数中，所以Function类型通常用做异步执行</p><ol><li><p>count_action.js</p><ul><li>新建一个action高阶函数，return一个函数体，函数体内实现异步操作</li><li>dispatch只能接收redux-thunk转换后的Function类型，redux-thunk是一个中间件，它的作用是把一个异步操作包装在一个函数中，并在适当的时候调用</li><li>return的函数体会接收到一个dispatch函数作为参数，异步结束后调用dispatch函数来设置状态</li></ul></li><li><p>store.js</p><ul><li>从store中引入applyMiddleware，再引入redux-thunk。</li><li>异步action使用，dispatch只能接收redux-thunk转换过的函数，添加中间件的操作需要在store中完成</li><li>调用createStore创建store增加第二个参数，调用applyMiddleware，并给applyMiddleware传参redux-thunk</li></ul></li></ol><h3 id="_05-react-redux容器及组件和ui组件连接" tabindex="-1">05_react-redux容器及组件和UI组件连接 <a class="header-anchor" href="#_05-react-redux容器及组件和ui组件连接" aria-label="Permalink to &quot;05_react-redux容器及组件和UI组件连接&quot;">​</a></h3><p>在react-redux中，组件分为容器组件和ui组件，在demo中将容器组件统一放置到新建的containers目录</p><ol><li><p>containers/count组件</p><ul><li>引入components/count这个ui组件</li><li>引入react-react的connec方法</li><li>调用connect函数的返回值就能得到一个容器组件，需要传入ui组件。<code>connect()(CountUI)</code>，注意这里是调用connect的返回值，也就是调用两次</li><li>最后抛出这个容器及组件</li></ul></li><li><p>App组件</p><ul><li>引入containers/count容器组件</li><li>引入redux/store文件，传入Count容器组件</li></ul></li><li><p>components/count组件</p><ul><li>暂时删除所有和store相关的内容</li></ul></li></ol><h3 id="_06-react-redux基本使用" tabindex="-1">06_react-redux基本使用 <a class="header-anchor" href="#_06-react-redux基本使用" aria-label="Permalink to &quot;06_react-redux基本使用&quot;">​</a></h3><ol><li><p>containers/count组件</p><ul><li>引入所有redux/count_action.js的方法</li><li>调用connect需要传两个参数，用于给ui组件传值，两个参数都需要return一个Object，ui组件通过props接收传参</li><li>第一个参数是state的映射mapStateTpProps，接收state参数，就是store.getStore()的返回值，mapStateTpProps返回需要传入ui组件的参数</li><li>第二个参数是dispatch的映射mapDispatchToProps，接收dispatch参数，就是store的dispatch方法，dispatch内部依然是传入action，mapDispatchToProps返回需要传入ui组件的方法</li></ul></li><li><p>components/count组件</p><ul><li>将删除的从store调用的方法和获取的状态，改为从props调用和获取</li><li>实际上对ui组件来说，使用react-redux只是修改了一下调用了api的名称，react-redux的主要逻辑都在容器组件</li></ul></li></ol><h3 id="_07-react-redux基本使用优化" tabindex="-1">07_react-redux基本使用优化 <a class="header-anchor" href="#_07-react-redux基本使用优化" aria-label="Permalink to &quot;07_react-redux基本使用优化&quot;">​</a></h3><ol><li><p>containers/count组件组件优化</p><ul><li>都改为匿名函数且使用箭头函数的写法</li><li>connect改变传参，第二个参数(mapDispatchToProps)直接写Object，value就是action函数体，react-redux内部会去执行了dispatch操作</li></ul></li><li><p>index.js</p><ul><li>不再需要store的subscribe监听，render组件是react-redux的能力之一，通过connect实现的</li><li>管理store，引入store、从react-redux引入Provider标签，嵌套App组件，并把store传入Provider标签，这样就相当于全局引入就不需要在后面的组件引入了</li></ul></li><li><p>App组件</p><ul><li>删除store的引入及传参</li></ul></li><li><p>文件层面优化</p><ul><li>删除components目录下的count组件，把这个ui组件的内容放到容器组件中，最终只抛出一个容器组件就可以</li></ul></li></ol><h3 id="_08-多个组件使用react-redux" tabindex="-1">08_多个组件使用react-redux <a class="header-anchor" href="#_08-多个组件使用react-redux" aria-label="Permalink to &quot;08_多个组件使用react-redux&quot;">​</a></h3><ol><li><p>新建person组件</p><ul><li>新建containers/person组件，先在组件内部不使用react-redux实现功能，输入框输入内容，添加到数据在列表展示</li></ul></li><li><p>person结合react-redux</p><ul><li>新建 actions 和 reducers 目录，分别存放count和person组件的action和reducer文件</li><li>修改count相关的action和reducer引用路径</li><li>contast增加addPerson常量</li><li>actions/person文件，新增addPersonAction方法返回action对象</li><li>reducers/person文件，新增personReducer方法返回加工后的personList</li><li>store中引入reducers/person，原来store只有一个countReducer，可以直接传入createStore，现在有多个reducer，需要组合reducer数据。引入react-redux的combineReducers函数，调用combineReducers组合count和person的reducer加工后数据，combineReducers方法组合后将返回值传入createStore，这样之后</li><li>多个组件使用redux之后，store.getState方法就会返回一个对象而不是原来的count，containers/count中connect的传参修改为state.count</li></ul></li></ol><h3 id="_09-组件间共享数据" tabindex="-1">09_组件间共享数据 <a class="header-anchor" href="#_09-组件间共享数据" aria-label="Permalink to &quot;09_组件间共享数据&quot;">​</a></h3><p>组件之间可以共享redux保存的数据，在容器组件中，connect的mapStateTpProps中的参数state对象就是redux中所有的数据，可以从state中获取对应的数据传给ui组件即可</p><blockquote><p>reducers的return值 如果和上次一样就不会更新了，特别要注意对象和数组</p></blockquote><h3 id="_10-redux开发者工具" tabindex="-1">10_redux开发者工具 <a class="header-anchor" href="#_10-redux开发者工具" aria-label="Permalink to &quot;10_redux开发者工具&quot;">​</a></h3><p>可以安装浏览器扩展Redux DevTools，查看redux的数据</p><p>项目代码里也需要安装引入,安装redux-devtools-extension</p><p>在store中引用redux-devtools-extension的composeWithDevTools方法，将返回值传入createStore的第二个参数</p><blockquote><p>如果createStoee没有第二个参数，可以直接调用，如果写了第二个参数，那需要把原来的第二个参数传参给composeWithDevTools方法</p></blockquote><p>reducers目录下新建index.js，汇总所有reducers统一抛出，在store中统一导入，在index.js中需要把所有加工的工作操作完成，所以combineReducers也在index.js中调用</p><h3 id="_11-rtk-同步" tabindex="-1">11_RTK_同步 <a class="header-anchor" href="#_11-rtk-同步" aria-label="Permalink to &quot;11_RTK_同步&quot;">​</a></h3><p>RTK：redux toolkit，官方推荐的工具集合简化redux的写法，安装：<code>npm i @reduxjs/toolkit</code>。</p><p>整体流程：创建具体模块的store对象，从store对象导出reducer函数，在汇总的store对象汇总所有模块的reducer。</p><ol><li><p>redux/modules/counterStore</p><ul><li>创建具体模块的store对象，导出所有action creator和reducer函数</li><li>引入@reduxjs/toolkit的createSlice方法，调用并传参，调用后返回一个store对象</li><li>createSlice配置传参一个Object， <ul><li>name: reducer的名称</li><li>initialState：初始化state对象</li><li>reducers：reducer作用是更新state的状态，可以接收state参数，更新state内的数据。</li></ul></li><li>获取action creator并导出：createSlice.actions获取action creator对象（简称action对象），也就是createSlice中的reducers，按需引入的方式导出</li><li>导出创建的store对象的reducer函数，在汇总store中使用</li></ul></li><li><p>redux/store</p><ul><li>汇总的store对象，导出注入到项目使用</li><li>引入counterStore</li><li>引入@reduxjs/toolkit的configureStore方法，调用并传参，返回一个store对象</li><li>configureStore配置传入一个Object <ul><li>reducer: 传入counterStore导出的reducer函数</li></ul></li><li>导出configureStore返回的store对象，注入到项目的根组件</li></ul></li><li><p>index.js</p><ul><li>引入redux/store</li><li>根目录的index文件，用react-redux的Provider标签嵌套App，注入store属性</li></ul></li><li><p>App.js组件使用redux数据</p><ul><li>从react-redux引入useSelector</li><li>已获取count状态字段为例，使用：<code>const { count } = useSelector(state =&gt; state.counter.count)</code></li></ul></li><li><p>App.js组件修改redux数据</p><ul><li>从react-redux引入useDispatch</li><li>获取dispatch函数：<code>const dispatch = useDispatch()</code></li><li>引入counterStore导出的action方法并传参给dispatch：<code>dispatch(actionName(传参))</code></li><li>counterStore的action方法使用action.payLoad接收参数<div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">incement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (state, action) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   // 接收传参</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(action.payload)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li></ul></li></ol><h3 id="_12-rtk-异步" tabindex="-1">12_RTK_异步 <a class="header-anchor" href="#_12-rtk-异步" aria-label="Permalink to &quot;12_RTK_异步&quot;">​</a></h3><ol><li><p>redux/modules/channelStore</p><ul><li>需要声明一个高阶函数，返回一个异步函数体，函数体内进行数据请求，调用action函数将异步返回的数据传入进行dispatch</li><li>最后需要导出这个高阶函数，不需要再导出action函数了</li></ul></li><li><p>App.js</p><ul><li>使用还是useSelector钩子</li><li>在useeffect钩子内获取数据，使用dispatch，调用channelStore导出的高阶函数</li></ul></li></ol>`,44),o=[a];function c(s,n,u,d,p,h){return i(),t("div",null,o)}const k=e(r,[["render",c]]);export{_ as __pageData,k as default};
