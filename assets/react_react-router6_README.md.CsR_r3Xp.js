import{_ as e,c as a,o as t,a4 as i}from"./chunks/framework.BHUpnhyN.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"react/react-router6/README.md","filePath":"react/react-router6/README.md"}'),l={name:"react/react-router6/README.md"},o=i('<h3 id="_01-一级路由切换" tabindex="-1">01_一级路由切换 <a class="header-anchor" href="#_01-一级路由切换" aria-label="Permalink to &quot;01_一级路由切换&quot;">​</a></h3><ul><li>安装react-router-dom</li><li>引入BrowserRouter组件、NavLink组件、Route组件、Routes组件</li><li>与router5不同的是，Route的component属性改为element属性，传入组件<code>&lt;Route path=&quot;/home&quot; element={ &lt;Home /&gt; }/&gt;</code></li><li>在router6用Routes替换Switch组件，嵌套所有Route组件，Routes组件内部不会重复匹配，只会显示第一个匹配到的path</li></ul><h3 id="_02-重定向navigate" tabindex="-1">02_重定向Navigate <a class="header-anchor" href="#_02-重定向navigate" aria-label="Permalink to &quot;02_重定向Navigate&quot;">​</a></h3><ul><li>router6不再使用Redirect组件重定向，改为使用Navigate组件</li><li>写法：Route组件的path属性匹配 / ，<code>&lt;Route path=&quot;/&quot; element={ &lt;Navigate to=&quot;/home&quot; /&gt; } /&gt;</code>，element属性需要使用Navigate组件重定向</li><li>Navigate组件只要被渲染，就会触发试图的切换（Home组件的sum案例）</li><li>Navigate跳转可以用to属性追加模式，也可以用replace替换模式</li></ul><h3 id="_03-路由链接的高亮" tabindex="-1">03_路由链接的高亮 <a class="header-anchor" href="#_03-路由链接的高亮" aria-label="Permalink to &quot;03_路由链接的高亮&quot;">​</a></h3><ul><li>5版本是NavLink给加的active类名，可以直接用activeClassName属性修改自定义的类名</li><li>6版本className可以写一个回调函数，回调内接收一个对象，根据对象的isActive属性判断当前导航是否被选中</li></ul><h3 id="_04-路由表" tabindex="-1">04_路由表 <a class="header-anchor" href="#_04-路由表" aria-label="Permalink to &quot;04_路由表&quot;">​</a></h3><ul><li>路由表的数据类型是Array，元素的Object，需要配置path和element属性，值和Route组件一样</li><li>使用：在函数式组件中返回<code>useRoutes(路由表Array)</code>，替换原routes组件，routes和route组件就不需要写了</li><li>路由表应该放到单独的文件中，抛出一个函数式组件，在其他组件直接引入这个函数式组件渲染</li></ul><h3 id="_05-嵌套路由" tabindex="-1">05_嵌套路由 <a class="header-anchor" href="#_05-嵌套路由" aria-label="Permalink to &quot;05_嵌套路由&quot;">​</a></h3><ul><li>在Home组件增加news和message组件的导航链接，6版本的子路由导航链接可以写相对路径，不需要写父级路径</li><li>Home组件引入Outlet组件占位，子路由的视图会渲染到这个组件的位置</li><li>在路由表的home组件里增加children属性，值是一个Array，message和news组件的路由配置</li></ul><h3 id="_06-路由传参-params" tabindex="-1">06_路由传参_params <a class="header-anchor" href="#_06-路由传参-params" aria-label="Permalink to &quot;06_路由传参_params&quot;">​</a></h3><ul><li>传参：<code>detail/参数1/参数2</code>，路径可以是相对路径也可以是绝对路径</li><li>路由表：path属性<code>detail/:参数1/:参数2</code></li><li>Detail组件接收：使用useParams，调用后返回一个Object，内部为传参的数据</li></ul><h3 id="_07-路由传参-search" tabindex="-1">07_路由传参_search <a class="header-anchor" href="#_07-路由传参-search" aria-label="Permalink to &quot;07_路由传参_search&quot;">​</a></h3><ul><li>传参：<code>detail?key=value&amp;key=value</code>，路径可以是相对路径也可以是绝对路径</li><li>Detail组件接收：使用useSearchParams，调用后返回一个Array，第一个元素是search对象，调用对象的get方法获取search参数，第二个是地方法，修改search参数</li><li>Detail组件接收：使用useLocation，调用后会获取到字符串的search参数</li></ul><h3 id="_08-路由传参-state" tabindex="-1">08_路由传参_state <a class="header-anchor" href="#_08-路由传参-state" aria-label="Permalink to &quot;08_路由传参_state&quot;">​</a></h3><ul><li>传参：to属性只传路径，新增一个state属性传参数，类型是Object</li><li>Detail组件接收：使用useLocation，调用后会获取到state对象，就是传递的参数</li></ul><h3 id="_09-编程式路由跳转-usenavigate" tabindex="-1">09_编程式路由跳转_useNavigate <a class="header-anchor" href="#_09-编程式路由跳转-usenavigate" aria-label="Permalink to &quot;09_编程式路由跳转_useNavigate&quot;">​</a></h3><ul><li>使用useNavigate可以模拟Link标签的路由跳转，使用：<code>const navigate = useNavigate()</code> 获取到navigate函数</li><li>navigate函数第一个参数是路径，string类型，第二个参数是一个配置对象，可以配置state传参或者打开方式replace</li><li>navigate函数可以传参-1或者1，表示后退或前进</li><li>使用useNavigate的组件处于路由的上下文，也就是需要被BrowserRouter嵌套</li></ul><h3 id="_10-useinroutercontext" tabindex="-1">10_useInRouterContext <a class="header-anchor" href="#_10-useinroutercontext" aria-label="Permalink to &quot;10_useInRouterContext&quot;">​</a></h3><ul><li>调用useInRouterContext，返回一个布尔值，用于判断是否处于路由的上下文（BrowserRouter嵌套），只要被BrowswrRouter类型的标签嵌套，就处于上下文</li></ul><h3 id="_11-usenavigationtype" tabindex="-1">11_useNavigationType <a class="header-anchor" href="#_11-usenavigationtype" aria-label="Permalink to &quot;11_useNavigationType&quot;">​</a></h3><ul><li>调用useNavigationType，返回一个字符串，分别为：pop、push、replace</li><li>push和replace是通过路由跳转来的，pop是刷新了整个页面，或者通过前进后退等方式进入的页面</li></ul><h3 id="_12-useoutlet" tabindex="-1">12_useOutlet <a class="header-anchor" href="#_12-useoutlet" aria-label="Permalink to &quot;12_useOutlet&quot;">​</a></h3><ul><li>呈现当前组件中的嵌套路由组件</li><li>如果嵌套的路由组件还没挂载就是null</li></ul><h3 id="_13-404" tabindex="-1">13_404 <a class="header-anchor" href="#_13-404" aria-label="Permalink to &quot;13_404&quot;">​</a></h3><ul><li>增加notFound组件</li><li>增加全局的404页面兜底，把现有App.jsx放大pages/index目录下，App.jsx负责渲染整个项目的路由展示</li><li>在route/index路由表中，将原来整个路由表放到Index组件的children内，外部增加404的跳转</li></ul>',26),r=[o];function u(s,n,c,h,_,d){return t(),a("div",null,r)}const g=e(l,[["render",u]]);export{p as __pageData,g as default};
